<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AQS框架概述(译文)</title>
      <link href="/2022/04/04/Code/Concurrence/AQS/"/>
      <url>/2022/04/04/Code/Concurrence/AQS/</url>
      
        <content type="html"><![CDATA[<p>作者: Doug Lea</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre>Most synchronizers (locks, barriers, etc.) in the J2SE1.5 java.util.concurrent package are constructed using a small framework based on class AbstractQueuedSynchro- nizer.This framework provides common mechanics for atomically managing synchronization state,blocking and unblocking threads, and queuing. The paper describes the rationale, design, implementation, usage, and performance of this framework</pre></details><p>大部分的同步器(锁, 屏障, etc.) 在J2SE1.5 <code>java.util.concurrent</code> 并发集合包<br>是使用一个<code>AbstractQueuedSynchronizer</code>作为基类的轻量级框架构建的. 这个框架为<br>自动管理同步状态, 阻塞唤醒线程, 排队提供通用的机制. 这篇论文对这个框架的原理, 设计<br>, 实现, 用法和性能做了阐述.</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre><h2>1. INTRODUCTION</h2>Javatm release J2SE-1.5 introduces package java.util.concurrent, a collection of medium-levelconcurrency support classes created via Java Community Process (JCP) Java Specification Request (JSR) 166.Among these components are a set of synchronizers – abstract data type (ADT) classes that maintain an internal synchronization state (for example, representing whether a lock is locked or unlocked), operations to update and inspect that state, and at least one method that will cause a calling thread to block if the state requires it, resuming when some other thread changes the synchronization state to permit it.Examples include various forms of mutual exclusion locks, read-write locks, semaphores, barriers, futures,event indicators, and handoff queues.<p>As is well-known (see e.g., [2]) nearly any synchronizer can be used to implement nearly any other.<br>For example, it is possible to build semaphores from reentrant locks, and vice versa. However,<br>doing so often entails enough complexity, overhead, and inflexibility to be at best a second-rate engineering option.<br>Further, it is conceptually unattractive. If none of these constructs are intrinsically more primitive than the others,<br>developers should not be compelled to arbitrarily choose one of them as a basis for building others. Instead,<br>JSR166 establishes a small framework centered on class AbstractQueuedSynchro- nizer, that provides common<br>mechanics that are used by most of the provided synchronizers in the package,<br>as well as other classes that users may define themselves.</p><p>The remainder of this paper discusses the requirements for this framework, the main ideas behind<br>its design and implementation, sample usages, and some measurements showing its performance characteristics.<br></pre></p></details><p>Java团队根据Java社区流程(JCP)Java特别请求(JSR)166发布J2SE-1.5时引入了<br><code>java.uti.concurrent</code>并发集合包, 一个中间件基本的并发支持类. 这些组件是<br>一个同步器的集合, 抽象数据类型(ADT)类维护一个内部的同步状态(例如, 代表<br>一把锁是锁住还是未锁住),操作来更新或者监控这个状态, 并且当状态需要的时候至少<br>提供一个方法用来调用线程阻塞, 当其他线程改变这个这个同步状态时可以唤醒.例子<br>包括各种形式的互斥锁, 读写锁, 信号量, 屏障, 未来任务, 事件指示, 以及传递队列.</p><p>正如已知的几乎所有同步器都可以用来实现其他的同步器. 例如, 可以使用一个可重入锁<br>可以构建信号量, 反之亦然.<br>然而, 这么做必定会带来大量的复杂度, 开销, 以及没有扩展性, 这是一个二流的工程选择.<br>进一步讲, 这么做概念上毫无吸引力. 如果这些结构本质上并没有比其他的更原生,<br>那么开发们不应该强行的选择它们中的一个来作为构建其他的基础.<br>作为代替, JSR166以 <code>AbstractQueuedSynchronizer</code> 构建了一个轻量框架,<br>为并发包里的同步器提供了通用的机制, 以及一些其他的用户可以自定义的类.</p><p>本论文的主旨是讨论这个框架的需求, 设计和实现的主要思想, 简单的用法, 以及对它的<br>性能指数的一些测量.</p><h2 id="2-需求"><a href="#2-需求" class="headerlink" title="2. 需求"></a>2. 需求</h2><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre><h2>2. REQUIREMENTS</h2><h3>2.1 Functionality</h3>Synchronizers possess two kinds of methods [7]: at least one acquire operation that blocksthe calling thread unless/until the synchronization state allows it to proceed, and at least one release operation that changes synchronization state in a way that may allow one or more blocked threads to unblock.The java.util.concurrent package does not define a single unified API for synchronizers.Some are defined via common interfaces (e.g., Lock), but others contain only specialized versions. So, acquire and release operations take a range of names and forms across different classes. For example, methods Lock.lock, Semaphore.acquire, CountDownLatch.await, and FutureTask.get all map to acquire operations in the framework. However, the package does maintain consistent conventions across classes to support a range of common usage options. When meaningful, each synchronizer supports:<p>• Nonblocking synchronization attempts (for example, tryLock) as well as blocking versions.<br>• Optional timeouts, so applications can give up waiting.<br>• Cancellability via interruption, usually separated into one version of acquire<br>that is cancellable, and one that isn’t.</p><p>Synchronizers may vary according to whether they manage only exclusive states – those<br>in which only one thread at a time may continue past a possible blocking point – versus<br>possible shared states in which multiple threads can at least sometimes proceed.<br>Regular lock classes of course maintain only exclusive state, but counting semaphores,<br>for example, may be acquired by as many threads as the count permits.<br>To be widely useful, the framework must support both modes of operation.<br>The java.util.concurrent package also defines interface Condition, supporting monitor-style<br>await&#x2F;signal operations that may be associated with exclusive Lock classes,<br>and whose implementations are intrinsically intertwined with their associated Lock classes.<br></pre></p></details><h3 id="2-1-功能"><a href="#2-1-功能" class="headerlink" title="2.1 功能"></a>2.1 功能</h3><p>同步器执行两种类型的方法: 至少一个<code>acquire</code>来阻塞调用线程直到同步状态允许它继续执行,<br>至少一个<code>release</code>操作来改变同步状态来允许一个或多个被阻塞线程解锁.<br><code>java.util.concurrent</code>并发包没有为同步器定义一个统一标准的API. 一些是通过通用的接口<br>(例如<code>Lock</code>)来定义, 但是其他的包括专门的版本.</p><p>所以, <code>acquire</code> 和 <code>release</code>操作在不同的类里有不同形式的名字. 例如, 方法<code>Lock.lock</code>,<br><code>Semaphore.acquire</code>, <code>CountDownLatch.await</code>,<code>FutureTask.get</code> 都对应着框架的<br><code>acquire</code>操作. 然而, 这个包并没有为不同的类维护一个一致的协议来支持一定范围的通用使用<br>选项范围. </p><p>有意义的是, 每个同步器支持如下三点:</p><ul><li>非阻塞的同步尝试(例如, <code>tryLock</code>)以及阻塞版本.</li><li>可选的超时, 应用可以放弃等待.</li><li>可通过中断实现取消, 通常分离成两个版本的<code>acquire</code>, 一个可以取消, 一个不可以.</li></ul><p>同步器状态管理有互斥和共享两种模式, 互斥模式下一次只能允许一个线程通过阻塞点, 共享模式<br>下一次可以通过多个线程.通常情况下一个锁类只维护互斥状态, 除了计数信号量可能被很多线程<br><code>acquire</code>作为允许通过的数量.为了兼容大部分场景, 框架必须同时支持这两种模式. </p><p><code>java.util.concurrent</code>并发包也定义了<code>Condition</code>接口, 支持互斥锁的监控器式的<br><code>await</code>&#x2F;<code>signal</code>操作, 这些实现是内聚在它们对应的锁类里.</p><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre><h3>2.2 Performance Goals</h3><p>Java built-in locks (accessed using synchronized methods and blocks) have long been a performance concern,<br>and there is a sizable literature on their construction (e.g., [1], [3]). However, the main focus of such<br>work has been on minimizing space overhead (because any Java object can serve as a lock) and on minimizing<br>time overhead when used in mostly-single-threaded contexts on uniprocessors. Neither of these are<br>especially important concerns for synchronizers: Programmers construct synchronizers only when needed,<br>so there is no need to compact space that would otherwise be wasted, and synchronizers are used almost<br>exclusively in multithreaded designs (increasingly often on multiprocessors) under which at least<br>occasional contention is to be expected. So the usual JVM strategy of optimizing locks primarily<br>for the zero-contention case, leaving other cases to less predictable “slow paths” [12]<br>is not the right tactic for typical multithreaded server applications that rely heavily on<br>java.util.concurrent. </p><p>Instead, the primary performance goal here is scalability: to predictably<br>maintain efficiency even, or especially, when synchronizers are contended. Ideally, the overhead<br>required to pass a synchronization point should be constant no matter how many threads are trying to<br>do so. Among the main goals is to minimize the total amount of time during which some thread is permitted to<br>pass a synchronization point but has not done so. However, this must be balanced against resource considerations,<br>including total CPU time requirements, memory traffic, and thread scheduling overhead. For example,<br>spinlocks usually provide shorter acquisition times than blocking locks, but usually waste cycles and<br>generate memory contention, so are not often applicable.</p><p>These goals carry across two general styles of use. Most applications should maximize aggregate throughput,<br>tolerating, at best, probabilistic guarantees about lack of starvation. However in applications such as<br>resource control, it is far more important to maintain fairness of access across threads, tolerating<br>poor aggregate throughput. No framework can decide between these conflicting goals on behalf of users;<br>instead different fairness policies must be accommodated.</p><p>No matter how well-crafted they are internally, synchronizers will create performance bottlenecks in some<br>applications. Thus, the framework must make it possible to monitor and inspect basic operations to allow users<br>to discover and alleviate bottlenecks. This minimally (and most usefully) entails providing a way to determine<br>how many threads are blocked.<br></pre></p></details><h3 id="2-2-性能目标"><a href="#2-2-性能目标" class="headerlink" title="2.2 性能目标"></a>2.2 性能目标</h3><p>Java 内置锁(通过<code>synchronized</code>关键字锁住方法和代码块)一直有性能问题, 并且它们的<br>实现结构有很多的问题. 然而, 这个工作的主要焦点是在最小化空间开销(因为任何java对象<br>都可以作为一个锁对象)和最小化时间开销, 当在单处理器以单线程为主的上下文中使用.<br>下面这些问题对同步器都不是主要问题:<br>程序员只在需要时构建同步器, 所以没有必要压缩可能会浪费的空间,<br>一个同步器在多线程设计(多处理器中更容易发生)中主要是互斥模式, 会有竞争出现.<br>所以JVM对内置锁的优化策略主要在<code>零-竞争</code>的场景,<br>对于其他的场景无法预测的<code>慢路径</code>处理策略主要依赖<code>java.util.concurrent</code>并发包.</p><p>于是, 这里主要的性能目标是可量测性: 甚至是可预见性的维护效率, 或者特别是, 当同步器被竞争的时候.<br>理想情况下, 通过同步点的开销应该是一个与线程数无关的常量.<br>其中的主要目标是最小化线程从允许有通过一个同步点到通过的持续时间总量.<br>然而, 这个必须会资源因素平衡, 包括总的CPU时间需求, 内存流量, 以及线程调度开销.<br>例如, 自旋锁通常比阻塞锁的时间需求更短, 但是会浪费循环和需要更多的内存竞争, 所以不经常使用.</p><p>这些目标通过两种使用方式达到. 大部分的应用一个个最大化总吞吐量, 能容忍(最好避免)饥饿.<br>然而在资源控制的应用中, 维护访问的线程的公平性更重要, 容忍较低的吞吐量.<br>没有框架可以在这些目标冲突中替用户决定选择哪种方案.<br>框架必须能适应不同的公平策略.</p><p>无论内部是多么精心的设计, 在某些应用中同步器都会存在性能瓶颈.<br>此外, 框架必须允许监控和观察基本操作让用户发现和减轻瓶颈.<br>这最小限度（也是最有用的）需要提供一种方法来确定有多少线程被阻塞。</p><h2 id="3-设计和实现"><a href="#3-设计和实现" class="headerlink" title="3. 设计和实现"></a>3. 设计和实现</h2><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre><h2>3. DESIGN AND IMPLEMENTATION</h2>The basic ideas behind a synchronizer are quite straightforward.<p>An acquire operation proceeds as:<br><code><br>    while (synchronization state does not allow acquire) &#123;<br>        enqueue current thread if not already queued;<br>        possibly block current thread;<br>    &#125;<br>    dequeue current thread if it was queued;<br></code></p><p>And a release operation is:<br><code><br>    update synchronization state;<br>    if (state may permit a blocked thread to acquire)<br>        unblock one or more queued threads;<br></code><br>Support for these operations requires the coordination of three basic components:<br>• Atomically managing synchronization state<br>• Blocking and unblocking threads<br>• Maintaining queues</p><p>It might be possible to create a framework that allows each of these<br>three pieces to vary independently.<br>However, this would neither be very efficient nor usable. For example,<br>the information kept in queue nodes must mesh with that needed for<br>unblocking, and the signatures of exported methods<br>depend on the nature of synchronization state.<br>The central design decision in the synchronizer framework was to choose<br>a concrete implementation of each of these three components, while still<br>permitting a wide range of options in how they are used.<br>This intentionally limits the range of applicability, but provides<br>efficient enough support that there is practically never a reason not<br>to use the framework (and instead build synchronizers from scratch) in<br>those cases where it does apply.</p><p></pre></p></details><p>同步器的背后的基本的理念非常直接. <code>acquire</code>操作执行流程如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(没有acquire到同步状态)&#123;</span><br><span class="line">    if(当前线程不在队列) 线程加入等待队列;</span><br><span class="line">    阻塞当前线程;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当前线程出队;</span><br></pre></td></tr></table></figure><p><code>release</code>操作执行流程如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">更新同步状态;</span><br><span class="line"></span><br><span class="line">if(状态允许一个阻塞线程来acquire)&#123;</span><br><span class="line">    唤醒一个或者多个阻塞排队线程;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现以上操作需要3个基本组件合作:</p><ul><li>原子性的管理同步状态</li><li>阻塞唤醒线程</li><li>维护等待队列</li></ul><p>获取有可能创建一个允许三个组件单独变化的框架.<br>然而, 这样做既效率低, 可用性又差.<br>例如, 保存在队列节点里的信息必须和<code>唤醒</code>紧密配合, 并且导出方法的签名基于同步状态的特性.<br>同步器框架的中心的设计思想是给这三个组件选择一个具体的实现, 同时对于如何使用依然允许一个广泛的选择.<br>这样做限制了适应的范围, 但是提供了足够高效的支持, 实际生产遇到的场景中没有任何<br>理由不使用这个框架(并且自己从零构建同步器).</p><h3 id="3-1-同步状态"><a href="#3-1-同步状态" class="headerlink" title="3.1 同步状态"></a>3.1 同步状态</h3><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre><h3>3.1 Synchronization State</h3>Class AbstractQueuedSynchronizer maintains synchro- nization state using only a single (32bit) int, and exports getState, setState, and compareAndSetState operations to access and update this state. These methods in turn rely on java.util.concurrent.atomic support providing JSR133 (Java Memory Model) compliant volatile semantics on reads and writes, and access to native compare-and-swap or load- linked/store-conditional instructions to implement compare- AndSetState, that atomically sets state to a given new value only if it holds a given expected value.<p>Restricting synchronization state to a 32bit int was a pragmatic decision.<br>While JSR166 also provides atomic operations on 64bit long fields, these<br>must still be emulated using internal locks on enough platforms that the<br>resulting synchronizers would not perform well.<br>In the future, it seems likely that a second base class, specialized for<br>use with 64bit state (i.e., with long control arguments), will be added.<br>However, there is not now a compelling reason to include it in the package.<br>Currently, 32 bits suffice for most applications. Only one java.util.concurrent<br>synchronizer class, CyclicBarrier, would require more bits to maintain state,<br>so instead uses locks (as do most higher-level utilities in the package).</p><p>Concrete classes based on AbstractQueuedSynchronizer must define methods<br>tryAcquire and tryRelease in terms of these exported state methods in order to<br>control the acquire and release operations. The tryAcquire method must return<br>true if synchronization was acquired, and the tryRelease method<br>must return true if the new synchronization state may allow future acquires.<br>These methods accept a single int argument that can be used to communicate<br>desired state; for example in a reentrant lock, to re-establish the recursion<br>count when re-acquiring the lock after returning from a condition wait.<br>Many synchronizers do not need such an argument, and so just ignore it.<br></pre></p></details><p><code>AbstractQueuedSynchronizer</code>类同步器只使用一个(32bit)int值维护同步状态, 并且提供<code>getState</code>,<br><code>setState</code>, 和<code>compareAndSetState</code>操作来访问和更新这个状态. 这些方法依靠<code>java.util.concurrent.atomic</code><br>原子包的支持, 由JSR133(Java内存模型)读写一致性<code>volatile</code>机制, 和使用原生方法<code>compare-and-swap</code> 和<br><code>load-linked/store-conditional</code> 指令来实现<code>compareAndSetState</code>, 这个方法可以原子性修改<code>state</code>的<br>值只有当它持有一个给予的期望值.</p><p>限制同步状态的值为32bit的int类型是根据实际情况决定的.<br>JSR166对于64bit的long类型自动也提供了原子性的操作, 在很多平台上这个必须使用一个内部锁模仿实现, 使得同步器的<br>性能不太好.<br>将来, 会提供第二个基类, 专门为使用64bit的state.<br>然而, 现在没有一个令人信服的理由把它加入到包里.<br>目前, 对于大部分应用32bit足够了. <code>java.util.concurrent</code>包下只有一个同步器类,<code>CyclicBarrier</code>需要更多的bit位<br>来维护<code>state</code>, 所以使用锁代替(在包里完成大部分的上层的使用).</p><p>基于<code>AbstractQueuedSynchronizer</code>的实现类必须定义方法<code>tryAcquire</code>和<code>tryRelease</code>,<br>根据这些导出的状态方法来控制<br><code>acquire</code>和<code>release</code>操作. 当同步被请求成功时, <code>tryAcquire</code>方法必须返回<code>true</code>, 如果一个新的同步状态允许<br>将来的<code>acquire</code>那么<code>tryRelease</code>必须返回<code>true</code>. 这些方法接受一个<code>int</code>参数用来交流想要的<code>state</code>; 例如,<br>在可重入锁, 当再次获取锁在从一个<code>condition wait</code>返回后统计递归数.<br>许多同步器不需要这个参数, 只需要忽略它.</p><h3 id="3-2-阻塞"><a href="#3-2-阻塞" class="headerlink" title="3.2 阻塞"></a>3.2 阻塞</h3><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre><h3>3.2 Blocking</h3>Until JSR166, there was no Java API available to block and unblock threads for purposes of creating synchronizers that are not based on built-in monitors. The only candidates were Thread.suspend and Thread.resume, which are unusable because they encounter an unsolvable race problem: If an unblocking thread invokes resume before the blocking thread has executed suspend, the resume operation will have no effect.<p>The java.util.concurrent.locks package includes a LockSup- port class with<br>methods that address this problem. Method LockSupport.park blocks the current<br>thread unless or until a LockSupport.unpark has been issued. (Spurious wakeups<br>are also permitted.) Calls to unpark are not “counted”, so multiple unparks<br>before a park only unblock a single park. Additionally, this applies per-thread,<br>not per-synchronizer. A thread invoking park on a new synchronizer might return<br>immediately because of a “leftover” unpark from a previous usage. However, in<br>the absence of an unpark, its next invocation will block. While it would be<br>possible to explicitly clear this state, it is not worth doing so. It is more<br>efficient to invoke park multiple times when it happens to be necessary.</p><p>This simple mechanism is similar to those used, at some level, in the Solaris-9<br>thread library [11], in WIN32 “consumable events”, and in the Linux NPTL thread<br>library, and so maps efficiently to each of these on the most common platforms<br>Java runs on. (However, the current Sun Hotspot JVM reference implementation on<br>Solaris and Linux actually uses a pthread condvar in order to fit into the<br>existing runtime design.) The park method also supports optional relative and<br>absolute timeouts, and is integrated with JVM Thread.interrupt<br>support — interrupting a thread unparks it.</p><p></pre></p></details><p>JSR166之前, 没有Java API可以阻塞和唤醒线程用于创建非基于内嵌锁的同步器.<br>唯一的候选人是<code>Thread.suspend</code>和<code>Thread.resume</code>, 但是根本没用, 因为<br>它们遇到了一个无法解决的竞太问题: 如果一个没有阻塞线程在阻塞线程被挂起之前<br>调用唤醒, 这个<br>唤醒操作<font color='red'>无效</font>.</p><p><code>java.util.concurrent.locks</code>包里有一个<code>LockSupport</code>类提供了方法解决这个问题.<br>方法 <code>LockSupport.park</code> 阻塞当前线程直到调用<code>LockSupport.unpark</code>.<br>(伪造的唤醒也可以.)调用<code>unpark</code>不会被”计数”, 所以在<code>park</code>之前多次<code>unpark</code>,只会<br><code>unlock</code>一个<code>park</code>.此外, 这个作用于线程而不是同步器. 一个线程在一个新的同步器里<br>调用<code>park</code>可能会立刻返回由于先前”残留”的<code>unpark</code>. 然而, 没有<code>unpark</code>, 下次调用<br>将会阻塞. 虽然它可以显式的清空这个状态, 但不值得这么做. 当它恰巧需要的时候, 多次<br>调用<code>park</code>更高效.</p><p>在某种程度上, 这个简单的机制和在<code>Solaris 9</code>线程库, <code>WIN32</code> 可消费事件, Linux NPTL 线程库<br>使用相似, 在大部分Java运行的平台上可以高效的映射. (然而, 当前Sun Hotspot JVM 在Solaris<br>和 Linux引用实现是使用一个pthread condvar 为了适应已有的运行设计.) <code>park</code>方法通用支持选择<br>相对时间和绝对时间超时, 并且完美的支持JVM <code>Thread.interrupt</code>方法 - 中断一个线程唤醒它.</p><h3 id="3-3-队列"><a href="#3-3-队列" class="headerlink" title="3.3 队列"></a>3.3 队列</h3><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre><h3>3.3 Queues</h3><p>The heart of the framework is maintenance of queues of blocked threads, which are<br>restricted here to FIFO queues. Thus, the framework does not support priority-based<br>synchronization.</p><p>These days, there is little controversy that the most appropriate choices for<br>synchronization queues are non-blocking data structures that do not themselves<br>need to be constructed using lower-level locks. And of these, there are two main<br>candidates: variants of Mellor-Crummey and Scott (MCS) locks [9], and variants of<br>Craig, Landin, and Hagersten (CLH) locks [5][8][10]. Historically, CLH locks have<br>been used only in spinlocks. However, they appeared more amenable than MCS for use<br>in the synchronizer framework because they are more easily adapted to handle<br>cancellation and timeouts, so were chosen as a basis. The resulting design is far<br>enough removed from the original CLH structure to require explanation.</p><p>A CLH queue is not very queue-like, because its enqueuing and dequeuing<br>operations are intimately tied to its uses as a lock. It is a linked queue<br>accessed via two atomically updatable fields, head and tail, both initially<br>pointing to a dummy node.</p><p>A new node, node, is enqueued using an atomic operation:<br><code><br>    do &#123;<br>        pred = tail;<br>    &#125; while(!tail.compareAndSet(pred, node));<br></code><br>The release status for each node is kept in its predecessor node.<br>So, the “spin” of a spinlock looks like:<br><code><br>    while (pred.status != RELEASED) ; // spin<br>    A dequeue operation after this spin simply entails setting the head<br></code><br>field to the node that just got the lock:<br><code><br>    head = node;<br></code><br>Among the advantages of CLH locks are that enqueuing and dequeuing are fast,<br>lock-free, and obstruction free (even under contention, one thread will always<br>win an insertion race so will make progress); that detecting whether any threads<br>are waiting is also fast (just check if head is the same as tail); and that release<br>status is decentralized, avoiding some memory contention.</p><p>In the original versions of CLH locks, there were not even links connecting nodes.<br>In a spinlock, the pred variable can be held as a local. However, Scott and Scherer[10]<br>showed that by explicitly maintaining predecessor fields within nodes, CLH locks can<br>deal with timeouts and other forms of cancellation: If a node’s predecessor cancels,<br>the node can slide up to use the previous node’s status field.</p><p>The main additional modification needed to use CLH queues for blocking synchronizers<br>is to provide an efficient way for one node to locate its successor. In spinlocks,<br>a node need only change its status, which will be noticed on next spin by its successor,<br>so links are unnecessary. But in a blocking synchronizer, a node needs to explicitly<br>wake up (unpark) its successor.</p><p>An AbstractQueuedSynchronizer queue node contains a next link to its successor.<br>But because there are no applicable techniques for lock-free atomic insertion of<br>double-linked list nodes using compareAndSet, this link is not atomically set as<br>part of insertion; it is simply assigned:<br>pred.next &#x3D; node;<br>after the insertion. This is reflected in all usages. The next link is treated only<br>as an optimized path. If a node’s successor does not appear to exist (or appears to<br>be cancelled) via its next field, it is always possible to start at the tail of the<br>list and traverse backwards using the pred field to accurately check if there really<br>is one.</p><p>A second set of modifications is to use the status field kept in each node for purposes<br>of controlling blocking, not spinning. In the synchronizer framework, a queued thread<br>can only return from an acquire operation if it passes the tryAcquire method defined<br>in a concrete subclass; a single “released” bit does not suffice. But control is still<br>needed to ensure that an active thread is only allowed to invoke tryAcquire when it<br>is at the head of the queue; in which case it may fail to acquire, and (re)block.<br>This does not require a per-node status flag because permission can be determined by<br>checking that the current node’s predecessor is the head. And unlike the case of<br>spinlocks, there is not enough memory contention reading head to warrant replication.<br>However, cancellation status must still be present in the status field.</p><p>The queue node status field is also used to avoid needless calls to park and unpark.<br>While these methods are relatively fast as blocking primitives go, they encounter<br>avoidable overhead in the boundary crossing between Java and the JVM runtime and&#x2F;or OS.<br>Before invoking park, a thread sets a “signal me” bit, and then rechecks synchronization<br>and node status once more before invoking park. A releasing thread clears status.<br>This saves threads from needlessly attempting to block often enough to be worthwhile,<br>especially for lock classes in which lost time waiting for the next eligible thread<br>to acquire a lock accentuates other contention effects. This also avoids requiring<br>a releasing thread to determine its successor unless the successor has set the signal<br>bit, which in turn eliminates those cases where it must traverse multiple nodes to<br>cope with an apparently null next field unless signalling occurs in conjunction<br>with cancellation.</p><p>Perhaps the main difference between the variant of CLH locks used in the synchronizer<br>framework and those employed in other languages is that garbage collection is relied<br>on for managing storage reclamation of nodes, which avoids complexity and overhead.<br>However, reliance on GC does still entail nulling of link fields when they are sure<br>to never to be needed. This can normally be done when dequeuing. Otherwise, unused<br>nodes would still be reachable, causing them to be uncollectable.</p><p>Some further minor tunings, including lazy initialization of the initial dummy node<br>required by CLH queues upon first contention, are described in the source code<br>documentation in the J2SE1.5 release.</p><p>Omitting such details, the general form of the resulting implementation of the<br>basic acquire operation (exclusive, noninterruptible, untimed case only) is:<br><code><br>    if (!tryAcquire(arg)) &#123;<br>        node = create and enqueue new node;<br>        pred = node's effective predecessor;<br>        while (pred is not head node || !tryAcquire(arg)) &#123;<br>            if (pred's signal bit is set)<br>                park();<br>            else<br>                compareAndSet pred's signal bit to true;<br>            pred = node's effective predecessor;<br>        &#125;<br>        head = node;<br>    &#125;<br></code><br>And the release operation is:<br><code><br>    if (tryRelease(arg) && head node's signal bit is set) &#123;<br>        compareAndSet head's signal bit to false;<br>        unpark head's successor, if one exists;<br>    &#125;<br></code><br>The number of iterations of the main acquire loop depends, of course, on the<br>nature of tryAcquire. Otherwise, in the absence of cancellation, each component<br>of acquire and release is a constant-time O(1) operation, amortized across<br>threads, disregarding any OS thread scheduling occuring within park.<br>Cancellation support mainly entails checking for interrupt or timeout upon<br>each return from park inside the acquire loop. A cancelled thread due to<br>timeout or interrupt sets its node status and unparks its successor so it<br>may reset links. With cancellation, determining predecessors and successors<br>and resetting status may include O(n) traversals (where n is the length of<br>the queue). Because a thread never again blocks for a cancelled operation,<br>links and status fields tend to restabilize quickly.</p><p></pre></p></details><p>框架的心脏是阻塞线程队列的维护, 这里限定为<code>FIFO</code>队列. 此外, 框架不支持基于优先级的同步.</p><p>这些天, 关于同步队列最合适的选择有一些争论, 同步队列是不需要使用低级别锁的非阻塞数据机构.<br>基于此, 有两个主要的候选人: MCS锁变体, CLH锁变体. 历史上, CLH锁只在自旋锁中使用. 然而.<br>在同步器框架中它们比MCS更容易控制, 因为它们更容易适应处理取消和超时, 所以被选做基础.<br>所产生的设计与原始的CLH结构非常遥远，需要进行解释。</p><p>一个CLH队列不是很像队列, 因为他的入队和出队操作与它作为锁的用途紧密相连. 它是一个链表队列,<br>通过两个原子更新的字段访问, 头和尾, 初始化时都是指向一个虚拟节点.</p><p><img src="https://scyblog.oss-cn-shanghai.aliyuncs.com/2022/04/04/node_status.jpg" alt="图片"></p><p>一个新的节点, 入队采用原子操作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    pred = tail;</span><br><span class="line">&#125; while(!tail.comapreAndSet(pred,node));</span><br></pre></td></tr></table></figure><p>每个节点的释放状态都保存在它前一个节点里.<br>所以, 自旋锁的<code>自旋</code>看起来像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(pred.status != RELEASED); //spin</span><br></pre></td></tr></table></figure><p>自旋之后的出队操作只需要设置头字段为刚持有这把锁的节点:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = code;</span><br></pre></td></tr></table></figure><p>CLH锁的优势是入队和出队操作快速, 无锁, 无阻塞(即使有竞争, 总有一个赢得插入竞赛的线程执行);<br>监测是否存在等待线程快速(只需要检查头是否等于尾);并且是否状态是去中心化的, 避免内存竞争.</p><p>CLH锁的原始版本里, 节点之间没有链接. 在自旋锁, 前节点变化可以当做本地变量.<br>然而, Scott 和 Scherer 展示通过显式维护前节点的字段, CLH锁可以处理超时和其他形式的取消:<br>如果一个节点的前节点取消了, 那么节点可以向前滑动以使用上一个节点的状态字段.</p><p>用CLH队列作为阻塞同步器的主要的改动是提供一个高效的方式来定位一个节点的后继节点.<br>在自旋锁里, 一个节点只需要改变它的状态, 就会被它的后继节点在下一次自旋里发现.<br>所以连接是没有必要的. 但是在阻塞队列同步器里, 一个节点需要显式的唤醒它的后继节点.</p><h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h4><p><em>(这里终于明白了AQS对CLH做了什么改动: 原来的CLH队列, 用的是自旋锁,<br><font bold='true' color='blue'> 节点之间没有<code>next</code>连接</font>, 只有<code>pred</code>链接, 一个节点释放锁,<br>不需要显式通知它的下一个节点, 只需要改变自己的状态, 那么下一个节点会自旋中发现前节点的状态改变,<br>从而可以获取锁. 但是AQS里用的的是阻塞线程, 一个节点释放, 后继节点处于阻塞中无法主动检测到前节点的状态改变,<br>所以需要<code>LockSupport.unpark(node.next.thread)</code>来显式的唤醒后继节点.)</em></p><p>一个AbstractQueuedSynchronizer队列节点包含一个指向后继节点的<code>next</code>链接.<br>但是因为那里没有合适的技术通过<code>compareAndSet</code>来实现双向链表的无锁原子插入,<br>所以这个链接在插入操作时并不是原子性的设置; 它只是简单赋值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred.next=node;</span><br></pre></td></tr></table></figure><p>插入之后. 它反映到所有的使用中. <code>next</code>链接只是作为一个优化路径. 如果一个节点的<br>后继节点通过它的<code>next</code>字段来访问时不存在(或者被取消), 它将会从尾节点开始反向遍历,<br>使用<code>pred</code>字段来精确的检查是否存在后继节点.</p><h4 id="源码解读-插入节点和寻找后继节点"><a href="#源码解读-插入节点和寻找后继节点" class="headerlink" title="源码解读: 插入节点和寻找后继节点"></a>源码解读: 插入节点和寻找后继节点</h4><ol><li>插入节点部分代码:<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node.prev = pred; <span class="comment">// 1 设置节点pred链接</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 2 设置tail节点</span></span><br><span class="line">    pred.next = node; <span class="comment">// 3 设置pred节点的next链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>插入操作一共三行代码, 当第2行执行成功时, 这个节点已经实质上插入到队列里, 但是<br>当第三行还没有执行的时候, 其他线程使用<code>pred.next</code>访问<code>pred</code>节点的后继节点时就会为<code>null</code>,<br>所以插入操作中<code>next</code>链接的设置并不是原子操作. 但是<code>pred</code>和<code>tail</code>的设置是原子操作,<br>所以更精确的查找后继节点的方法是, 从尾节点开始反向遍历. 源码也是这么实现的:</li><li>寻找后继节点代码:<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node s = node.next;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 反向遍历到当前节点为止(不包括当前)</span></span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 寻找没有取消的后继节点</span></span><br><span class="line">            s = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>第二个改动是每个节点保存一个状态字段用来控制阻塞, 而不是自旋. 在同步器框架, 一个入队的线程<br>只能从一个<code>acquire</code>操作返回, 如果它通过了子类定义的<code>tryAcquire</code>方法; 单一个<code>release</code>还不够.<br>但是控制依然需要, 以确保一个活动的线程只有它处于队列的最前面时调用<code>tryAcquire</code>;<br>如果<code>acquire</code>失败, 会再次阻塞.这并不需要每个节点的状态标记, 因为可以通过检查当前节点<br>的前节点是否是头来确定权限. 不同于自旋锁场景, 这里没有足够的内存争用读取头来保证复制.??<br>然而, 取消状态依然在状态字段中.</p><p>队列节点状态字段也用来避免不必要的<code>park</code>和<code>unpark</code>调用.<br>这些方法相对于原生的阻塞要更快, 它们避免了在Java和JVM运行时&#x2F;或操作系统的边界切换开销.<br>在调用<code>park</code>之前, 一个线程设置一个<code>唤醒我</code>bit, 然后再次检查同步和节点状态,再调用<br><code>park</code>之前再来一次.<br>一个释放线程清空状态. 这使得线程不必努力阻塞得足够有价值, 特别是对于锁类, 等待下一个合格<br>线程来获取锁的时间损失严重受到竞争影响. 这个也避免了需要一个释放线程来确定它的后继者, 除非<br>后继者已经设置了信号位, 反过来这也消除了那些它必须遍历多个节点来处理<code>next</code>字段为空的情况,<br>除非信号和取消同时产生.</p><p>也许同步器框架中使用的CLH锁的变体和其他语言中使用的主要区别在于依赖垃圾收集来管理节点<br>的内存回收，这避免了复杂性和开销.<br>当然当确定链接字段不再需要时, 依赖垃圾回收依然需要确保它们被设为null.<br>这通常可以在出队时完成. 否则, 无用的节点依然可以到达, 使它们无法回收.</p><p>一些进一步的优化, 包括CLH队列第一竞争时需要的虚拟节点的懒初始化, 在J2SE1.5发布的源码文档<br>作了描述.</p><p>忽略这些细节, 基础的<code>acquire</code>操作最终实现的一般形式(仅限互斥, 不中断, 无超时情况)是:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tryAcquire(arg))&#123;</span><br><span class="line">     node = <span class="keyword">new</span> Node();</span><br><span class="line">     enqueue(node);</span><br><span class="line">     pred = node.predecessor();</span><br><span class="line">     <span class="keyword">while</span>(pred != head || !tryAcquire(arg))&#123;</span><br><span class="line">         <span class="keyword">if</span>(pred.ws==SIGNAL)&#123;<span class="comment">// 前节点的ws(waitStatus)值是否SIGNAL </span></span><br><span class="line">             park();</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">// 这里先不park, 再跑一次循环, 尝试acquire, 如果失败就会park   </span></span><br><span class="line">             <span class="comment">// 看源码时, 我们会好奇SIGNAL这个值是什么时候第一次设置的, 答案就是在这里, 目的是下一次循环park</span></span><br><span class="line">             <span class="comment">// 问题: 为什么这里设置完 SIGNAL不直接park? </span></span><br><span class="line">             <span class="comment">// 答案: 因为release操作里, 只有头结点ws值是SIGNAL才会唤醒后继节点, 那么如果这行代码还未执行, </span></span><br><span class="line">             <span class="comment">// release将会错过唤醒后继节点的机会. 如果这个节点在这里park, 那么将会永远沉睡, 没有人来唤醒.                        </span></span><br><span class="line">             compareAndSet(pred.ws, SIGNAL); </span><br><span class="line">         &#125;</span><br><span class="line">         pred = node.predecessor();</span><br><span class="line">     &#125;                                                                                                                                                                                                         </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <code>release</code> 操作是:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tryRelease(arg) &amp;&amp; head.ws == SIGNAL) &#123; <span class="comment">// 释放成功后, 必须头结点的ws值为SIGNAL才会唤醒后继节点</span></span><br><span class="line">    compareAndSet(head.ws,<span class="number">0</span>); <span class="comment">// 清空头结点的等待状态ws</span></span><br><span class="line">    unpark(head.successor()) <span class="comment">// 唤醒后继节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然, 主<code>acquire</code>循环迭代的次数取决于<code>tryAcquire</code>的性质. 否则, 在没有取消<br>的情况下, 不考虑在<code>park</code>时发生的任何系统调用发生的消耗, <code>acquire</code>和<code>release</code><br>的每个组件都是常量时间O(1)操作.<br>支持取消主要是确保在<code>acquire</code>循环内部每次从<code>park</code>返回检查中断和超时.<br>一个由于超时或者中断取消的线程会修改它的节点状态并且唤醒它的后继节点,<br>所以它可能会重置链接. 当取消时, 确定前节点和后继节点并重置状态可能包括O(n)遍历<br>(n是队列的长度).<br>因为线程不会再阻塞已取消的操作, 所以链接和状态字段往往会迅速重新稳定.</p><h3 id="3-4-条件队列"><a href="#3-4-条件队列" class="headerlink" title="3.4 条件队列"></a>3.4 条件队列</h3><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre><h3>3.4 Condition Queues</h3><p>The synchronizer framework provides a ConditionObject class for use<br>by synchronizers that maintain exclusive synchronization and conform<br>to the Lock interface. Any number of condition objects may be<br>attached to a lock object, providing classic monitor-style await,<br>signal, and signalAll operations, including those with timeouts,<br>along with some inspection and monitoring methods.</p><p>The ConditionObject class enables conditions to be efficiently<br>integrated with other synchronization operations, again by fixing<br>some design decisions. This class supports only Java-style monitor<br>access rules in which condition operations are legal only when the<br>lock owning the condition is held by the current thread (See [4]<br>for discussion of alternatives). Thus, a ConditionObject attached<br>to a ReentrantLock acts in the same way as do built-in monitors<br>(via Object.wait etc), differing only in method names,<br>extra functionality, and the fact that users can declare multiple<br>conditions per lock.</p><p>A ConditionObject uses the same internal queue nodes as<br>synchronizers, but maintains them on a separate condition queue.<br>The signal operation is implemented as a queue transfer from<br>the condition queue to the lock queue, without necessarily<br>waking up the signalled thread before it has re-acquired its lock.</p><p>The basic await operation is:<br><code><br>create and add new node to condition queue;<br>release lock;<br>block until node is on lock queue;<br>re-acquire lock;<br></code><br>And the signal operation is:<br><code><br>transfer the first node from condition queue to lock queue;<br></code><br>Because these operations are performed only when the lock is held,<br>they can use sequential linked queue operations (using a<br>nextWaiter field in nodes) to maintain the condition queue.<br>The transfer operation simply unlinks the first node from the<br>condition queue, and then uses CLH insertion to attach it to<br>the lock queue.</p><p>The main complication in implementing these operations is dealing<br>with cancellation of condition waits due to timeouts or<br>Thread.interrupt. A cancellation and signal occuring at<br>approximately the same time encounter a race whose outcome conforms<br>to the specifications for built-in monitors. As revised in JSR133,<br>these require that if an interrupt occurs before a signal, then the<br>await method must, after re-acquiring the lock, throw<br>InterruptedException. But if it is interrupted after a signal,<br>then the method must return without throwing an exception,<br>but with its thread interrupt status set.</p><p>To maintain proper ordering, a bit in the queue node status<br>records whether the node has been (or is in the process of being)<br>transferred. Both the signalling code and the cancelling code try<br>to compareAndSet this status. If a signal operation loses this race,<br>it instead transfers the next node on the queue, if one exists.<br>If a cancellation loses, it must abort the transfer, and then await<br>lock re-acquisition. This latter case introduces a potentially<br>unbounded spin. A cancelled wait cannot commence lock re- acquisition<br>until the node has been successfully inserted on the lock queue,<br>so must spin waiting for the CLH queue insertion compareAndSet being<br>performed by the signalling thread to succeed. The need to spin<br>here is rare, and employs a Thread.yield to provide a scheduling<br>hint that some other thread, ideally the one doing the signal,<br>should instead run. While it would be possible to implement here<br>a helping strategy for the cancellation to insert the node,<br>the case is much too rare to justify the added overhead that this<br>would entail. In all other cases, the basic mechanics here and<br>elsewhere use no spins or yields, which maintains reasonable<br>performance on uniprocessors.<br></pre></p></details><p>同步器框架提供了一个<code>ConditionObject</code>类, 供维护互斥同步的同步器使用,<br>并且遵循<code>Lock</code>接口. 任意数量的条件对象可以被附加到锁对象上, 提供经典的<br>监控器式的等待, 唤醒, 和唤醒全部操作, 包括超时, 以及一些监控和检测的方法.</p><p><code>ConditionObject</code>类再次通过修复一些设计决策, 使条件与其他同步操作有效的<br>集成. 此类只支持java类型的监控器访问规则, 其中只有当拥有该条件的锁被<br>当前线程持有时, 条件操作才是合法的. 因此, 附加到<code>ReentrantLock</code>重入锁的<br><code>ConditionObject</code>条件对象和内置监控器的操作相同, 区别只有方法名,<br>额外的功能, 事实是每把锁用户可以声明多个条件.</p><p><code>ConditionObject</code>和同步器使用同样的内部队列节点, 但是使用一个不同的<br>条件队列维护它们. 信号操作被实现为从条件队列到锁队列的队列传输, 在被从条件<br>队列移出的线程在它再次获取到锁之前不需要被解除阻塞.(疑问: 不解除阻塞怎么抢锁?)<br>基本等待操作是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建一个新节点并添加到条件队列;</span><br><span class="line">释放锁;</span><br><span class="line">阻塞该节点直到回到锁队列;</span><br><span class="line">再次获取锁.</span><br></pre></td></tr></table></figure><p>唤醒操作是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将条件队列的第一个节点转移到锁队列;</span><br></pre></td></tr></table></figure><p>只有当前线程持有锁的时候才能执行这些操作, 它们可以使用按顺序的链表队列操作<br>(节点里使用一个<code>nextWaiter</code>字段)来维护条件队列.<br>转移操作只需要简单地修改等待队列第一个节点的链接, 然后使用CLH的插入将它加入<br>到锁队列.</p><p>实现这些操作的主要复杂的地方在于处理由于超时或线程中断而引起的条件等待取消.<br>取消和信号同时发生, 那么会遇到一个符合内置监视器规格的竞塞.<br>根据JSR133的修订, 要求信号之前发生中断, 那么<code>await</code>方法, 再重新获取锁之后,<br>必须抛出<code>InterruptedException</code>异常. 但是如果它是在信号之后中断, 那么该<br>方法必须返回, 不需要抛出异常, 当是它所在的线程需要设置中断状态.</p><p>为了保持正确的顺序, 队列节点状态的一个<code>bit</code>记录节点是否(或则已经)转移.<br>唤醒代码和取消代码两者都会努力<code>compareAndSet</code>这个状态. 如果一个唤醒<br>操作在竞赛中输了, 它会转移队列里下一个节点作为代替.<br>如果一个取消操作输了, 它必须禁止此次转移, 然后等待再次获取锁. 后者的场景<br>会引入一个潜在的无边界自旋. 在节点成功插入到锁队列之前, 一个取消的等待不能<br>开始获取锁. 所以必须自旋等待唤醒的线程使用<code>compareAndSet</code>插入CLH队列成功.<br>这里很少需要自旋, 并且采用<code>Thread.yield</code>来提供一个调度提示其他线程, 理想<br>的是发信号的线程应该运行. (解读:这里意思是发信号的线程<code>Thread.yield</code>并不理想,<br>而是应该保持运行). 虽然这里可以实现取消插入节点的帮助策略, 但这个场景非常罕见, 无法<br>证明这将带来的增加开销. 在所有其他的场景下, 不使用自旋或<code>yields</code>的基本机制<br>可以在单处理器上保持合理的性能.                   </p><h2 id="4-用法"><a href="#4-用法" class="headerlink" title="4. 用法"></a>4. 用法</h2><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre><h2>4. USAGE</h2>Class AbstractQueuedSynchronizer ties together the above functionality and serves as a "template method pattern" [6] base class for synchronizers. Subclasses define only the methods that implement the state inspections and updates that control acquire and release. However, subclasses of AbstractQueuedSynchronizer are not themselves usable as synchronizer ADTs, because the class necessarily exports the methods needed to internally control acquire and release policies, which should not be made visible to users of these classes. All java.util.concurrent synchronizer classes declare a private inner AbstractQueuedSynchronizer subclass and delegate all synchronization methods to it. This also allows public methods to be given names appropriate to the synchronizer.<p>For example, here is a minimal Mutex class, that uses synchronization<br>state zero to mean unlocked, and one to mean locked. This class does<br>not need the value arguments supported for synchronization methods,<br>so uses zero, and otherwise ignores them.</p><code>class Mutex &#123;    class Sync extends AbstractQueuedSynchronizer &#123;        public boolean tryAcquire(int ignore) &#123;            return compareAndSetState(0, 1);         &#125;        public boolean tryRelease(int ignore) &#123;            setState(0); return true;         &#125;     &#125;     private final Sync sync = new Sync();         public void lock() &#123;      sync.acquire(0);      &#125;      public void unlock() &#123;         sync.release(0);      &#125;&#125;        </code><p>A fuller version of this example, along with other usage guidance<br>may be found in the J2SE documentation. Many variants are of course<br>possible. For example, tryAcquire could employ “test- and-test-and-set”<br>by checking the state value before trying to change it.</p><p>It may be surprising that a construct as performance-sensitive<br>as a mutual exclusion lock is intended to be defined using a<br>combination of delegation and virtual methods. However, these<br>are the sorts of OO design constructions that modern dynamic compilers<br>have long focussed on. They tend to be good at optimizing away this<br>overhead, at least in code in which synchronizers are invoked frequently.</p><p>Class AbstractQueuedSynchronizer also supplies a number of<br>methods that assist synchronizer classes in policy control.<br>For example, it includes timeout and interruptible versions of<br>the basic acquire method. And while discussion so far has focussed<br>on exclusive-mode synchronizers such as locks, the AbstractQueuedSynchronizer<br>class also contains a parallel set of methods (such as acquireShared)<br>that differ in that the tryAcquireShared and tryReleaseShared methods<br>can inform the framework (via their return values) that further acquires<br>may be possible, ultimately causing it to wake up multiple threads<br>by cascading signals.</p><p>Although it is not usually sensible to serialize (persistently store<br>or transmit) a synchronizer, these classes are often used in turn to<br>construct other classes, such as thread-safe collections, that are<br>commonly serialized. The AbstractQueuedSynchronizer and ConditionObject<br>classes provide methods to serialize synchronization state, but not<br>the underlying blocked threads or other intrinsically transient bookkeeping.<br>Even so, most synchronizer classes merely reset synchronization state<br>to initial values on deserialization, in keeping with the implicit<br>policy of built-in locks of always deserializing to an unlocked state.<br>This amounts to a no-op, but must still be explicitly supported to enable<br>deserialization of final fields.<br></pre></p></details><p><code>AbstractQueuedSynchronizer</code>类将上述功能连接在一起, 并作为同步器的模板方法模式的<br>基类. 子类只需要定义实现控制获取和释放状态的检查和更新的方法. 然而, <code>AbstractQueuedSynchronizer</code><br>的子类自身并不用作同步器的抽象数据类型, 因为类必须导出内部控制获取和释放策略的方法,<br>不应使其被这些类的使用者可见. <code>java.util.concurrent</code>包里所有的同步器类声明了一个<br>私有的内部<code>AbstractQueuedSynchronizer</code>子类并且把所有同步器的方法都委托给它.<br>这还允许公共方法指定适合同步器的名称.</p><p>例如, 这里有一个最简的互斥类, 使用同步状态0代表未锁主, 1代表被锁住. 这个类不需要<br>给同步方法传参数, 所以使用0, 或者忽略它们.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> ignore)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> ignore)</span> &#123;</span><br><span class="line">            setState(<span class="number">0</span>); <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>(); </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123; </span><br><span class="line">     sync.acquire(<span class="number">0</span>); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123; </span><br><span class="line">        sync.release(<span class="number">0</span>); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个案例的完整版, 以及其他的使用指南, 可以J2SE的文档找到. 当然可以有许多的变化.<br>例如, <code>tryAcquire</code>通过在改变<code>state</code>值之前检查<code>state</code>值实现<code>test- and-test-and-set</code>.<br>令人惊讶的是, 向互斥锁这样对性能敏感的结构会使用委托组合和虚拟方法来定义.<br>然而, 这些都是现代冬天编译器长期以来一直关注的面向对象动态设计结构. 它们往往擅长优化以消除<br>这种开销, 至少在经常调用同步器的代码中是这样.</p><p><code>AbstractQueuedSynchronizer</code>类在策略控制也提供了很多方法帮助同步器类. 例如, 它包含了<br>基本<code>acquire</code>方法的超时和中断版本. 虽然到目前为止讨论的焦点一直集中在互斥模式的同步器<br>, 例如锁, <code>AbstractQueuedSynchronizer</code>类也包含一组并行的方法(比如<code>acquireShared</code>),<br>不同的<code>tryAcquireShared</code>和<code>tryReleaseShared</code>方法可以通知框架(通过它们的返回值)来<br>进一步获取也是可能的, 最终使得它唤醒多个线程通过信号级联.</p><p>尽管通常不宜序列化同步器(持续存储和传输), 这些类通过用来构建其他类, 比如线程安全的集合,<br>经常被序列化. <code>AbstractQueuedSynchronizer</code>和<code>ConditionObject</code>类提供方法来序列化<br>同步状态, 但不是潜在的阻塞线程或者瞬态薄记.  即便如此, 大部分的同步器类也只是在反序列化<br>的时候将同步状态重设为初始值, 为了符合内置锁的隐式策略, 总是反序列化到一个未锁状态.<br>这相当于没有操作, 但是必须显式支持使得可以反序列化<code>final</code>字段.</p><h3 id="4-1-公平控制"><a href="#4-1-公平控制" class="headerlink" title="4.1 公平控制"></a>4.1 公平控制</h3><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre><h3>4.1 Controlling Fairness</h3> Even though they are based on FIFO queues, synchronizers are not necessarily fair. Notice that in the basic acquire algorithm (Section 3.3), tryAcquire checks are performed before queuing. Thus a newly acquiring thread can “steal” access that is "intended" for the first thread at the head of the queue.<p>This barging FIFO strategy generally provides higher aggregate throughput than<br>other techniques. It reduces the time during which a contended lock is available<br>but no thread has it because the intended next thread is in the process of<br>unblocking. At the same time, it avoids excessive, unproductive contention by<br>only allowing one (the first) queued thread to wake up and try to acquire upon<br>any release. Developers creating synchronizers may further accentuate barging<br>effects in cases where synchronizers are expected to be held only briefly by<br>defining tryAcquire to itself retry a few times before passing back control.</p><p>Barging FIFO synchronizers have only probablistic fairness properties.<br>An unparked thread at the head of the lock queue has<br>an unbiased chance of winning a race with any incoming barging thread,<br>reblocking and retrying if it loses. However, if incoming threads arrive f<br>aster than it takes an unparked thread to unblock, the first thread in the<br>queue will only rarely win the race, so will almost always reblock, and its<br>successors will remain blocked. With briefly-held synchronizers, it is common<br>for multiple bargings and releases to occur on multiprocessors during the time<br>the first thread takes to unblock. As seen below, the net effect is to maintain<br>high rates of progress of one or more threads while still at least probabilistically<br>avoiding starvation.</p><p>When greater fairness is required, it is a relatively simple matter to arrange it.<br>Programmers requiring strict fairness can define tryAcquire to fail (return false)<br>if the current thread is not at the head of the queue, checking for this using<br>method getFirstQueuedThread, one of a handful of supplied inspection methods.</p><p>A faster, less strict variant is to also allow tryAcquire to succeed if the the queue<br>is (momentarily) empty. In this case, multiple threads encountering an empty queue may<br>race to be the first to acquire, normally without enqueuing at least one of them.<br>This strategy is adopted in all java.util.concurrent synchronizers supporting a “fair”<br>mode.</p><p>While they tend to be useful in practice, fairness settings have no guarantees,<br>because the Java Language Specification does not provide scheduling guarantees.<br>For example, even with a strictly fair synchronizer, a JVM could decide to run a<br>set of threads purely sequentially if they never otherwise need to block waiting for<br>each other. In practice, on a uniprocessor, such threads are<br>likely to each run for a time quantum before being pre-emptively context-switched.<br>If such a thread is holding an exclusive lock, it will soon be momentarily switched back,<br>only to release the lock and block now that it is known that another thread needs the<br>lock, thus further increasing the periods during which a synchronizer is available but<br>not acquired. Synchronizer fairness settings tend to have even greater impact on<br>multiprocessors, which generate more interleavings, and hence more opportunities<br>for one thread to discover that a lock is needed by another thread.</p><p>Even though they may perform poorly under high contention when protecting briefly-held<br>code bodies, fair locks work well, for example, when they protect relatively long code<br>bodies and&#x2F;or with relatively long inter-lock intervals, in which case barging provides<br>little performance advantage and but greater risk of indefinite postponement.<br>The synchronizer framework leaves such engineering decisions to its users.</p><p></pre></p></details><p>即使它们是基于<code>FIFO</code>队列, 同步器不是必须公平. 注意一下基础的<code>acquire</code>算法, 在入队之前执<br>行了<code>tryAcquire</code>. 那么一个新来的想要获取的线程可以从队列头部第一个准备获取的线程手里<code>偷到</code><br>访问权.</p><p>这个允许插队的<code>FIFO</code>策略主要比其他技术提供更高的聚合吞吐量. 它减少了锁的闲置时间, 即一把<br>被竞争的锁虽然可以获取但由于下一个线程还在唤醒的过程中导致没有线程持有它. 与此同时, 它只<br>允许一个(第一个)队列的线程在任何释放的时候醒来并尝试获取, 从而避免了过度的无效的争用.<br>开发人员可能在创建同步器的时候进一步的增强闯入效果, 只需要在定义<code>tryAcquire</code>的时候自身<br>多试几次, 在返回控制之前.</p><p><img src="https://scyblog.oss-cn-shanghai.aliyuncs.com/code/barging_thread.png"></p><p>插队式先进先出同步器只有一个只有概率性的公平性. 锁队列头部的唤醒线程面对突然插队的线程<br>有一个无偏差的机会赢得比赛, 输了的话会再次阻塞并重新获取. 然而, 如果闯入的线程到达的速率<br>比唤醒线程的速度要快, 那么队列里第一个线程很难赢得竞赛, 所以将会一直再次阻塞, 并且它的<br>后继节点也会一直保持阻塞. 对于简单持有的同步器, 第一个线程解除阻塞的时间内, 在多处理器上<br>发生插队和释放是很常见的. 如下图所示, 净效应是保持一个或多个线程高执行率, 并尽可能<br>避免出现饥饿.</p><p>当需要更高的公平性时, 安排它是一件相对简单的事情. 程序员需要严格的公平性,<br>使用方法<code>getFirstQueuedThread</code>检查, 如果当前线程不在队列的头部<br>可以定义<code>tryAcquire</code>失败(返回<code>false</code>).</p><p>一个更快, 但不严格的变体时, 如果队列(暂时)为空, 也允许<code>tryAcquire</code>成功.<br>在这个场景下, 多个线程遇到一个空队列可能会竞赛来第一个获取, 通常至少没有一个<br>人在排队. <code>java.util.concurrent</code>并发包里所有的同步器都采用这个策略来<br>支持<code>公平性</code>模式.</p><p>虽然它们在实践中很有用, 但公平性设置没有保证, 因为Java语言说明没有提供调度保证.<br>例如, 即使一个严格公平的同步器, 一个JVM可以纯粹按顺序决定运行一组线程, 如果<br>它们从来不需要阻塞彼此等待。 在实践中, 但单处理器里, 这样的线程很可能在先发制人的<br>上下文切换之前, 先运行一个时间片. 如果这样一个线程持有一个互斥锁, 它将很快就会<br>被切换会, 只有释放这个锁并且阻塞才会直到另一个线程需要那把锁, 从而进一步增加了<br>同步器可用但没有获取的持续时间. 同步器公平性的设置在产生更多交互的多处理器有更<br>大的影响, 因此一个线程有更多的机会发现另一个线程需要锁.</p><p>即使在保护短暂持有的代码体时，它们可能在高争用下表现不佳，但公平锁工作得很好，<br>例如，当它们保护相对较长的代码体和&#x2F;或相对较长的互锁间隔时，在这种情况下，<br>插队几乎不能提供什么性能优势，但无限期延迟的风险更大. 同步器框架把这个工程<br>决定留给用户来做.</p><h3 id="4-2-同步器实现类"><a href="#4-2-同步器实现类" class="headerlink" title="4.2 同步器实现类"></a>4.2 同步器实现类</h3><details><summary><font size="2" color="grey"><i>原文</i></font></summary><pre><h3>4.2 Synchronizers</h3> Here are sketches of how java.util.concurrent synchronizer classes are defined using this framework:The ReentrantLock class uses synchronization state to hold the (recursive) lock count. When a lock is acquired, it also records the identity of the current thread to check recursions and detect illegal state exceptions when the wrong thread tries to unlock. The class also uses the provided ConditionObject, and exports other monitoring and inspection methods. The class supports an optional "fair" mode by internally declaring two different AbstractQueuedSynchronizer subclasses (the fair one disabling barging) and setting each ReentrantLock instance to use the appropriate one upon construction.<p>The ReentrantReadWriteLock class uses 16 bits of the synchronization<br>state to hold the write lock count, and the remaining 16 bits to hold<br>the read lock count. The WriteLock is otherwise structured in the<br>same way as ReentrantLock. The ReadLock uses the acquireShared methods<br>to enable multiple readers.</p><p>The Semaphore class (a counting semaphore) uses the synchronization<br>state to hold the current count. It defines acquireShared to decrement<br>the count or block if nonpositive, and tryRelease to increment the count,<br>possibly unblocking threads if it is now positive.</p><p>The CountDownLatch class uses the synchronization state to represent<br>the count. All acquires pass when it reaches zero.</p><p>The FutureTask class uses the synchronization state to represent the<br>run-state of a future (initial, running, cancelled, done). Setting or<br>cancelling a future invokes release, unblocking threads waiting for<br>its computed value via acquire.</p><p>The SynchronousQueue class (a CSP-style handoff) uses internal wait-nodes<br>that match up producers and consumers. It uses the synchronization state<br>to allow a producer to proceed when a consumer takes the item, and vice-versa.</p><p>Users of the java.util.concurrent package may of course define their<br>own synchronizers for custom applications. For example, among those<br>that were considered but not adopted in the package are classes providing<br>the semantics of various flavors of WIN32 events, binary latches,<br>centrally managed locks, and tree-based barriers.</p><p></pre></p></details><p>下面是<code>java.util.concurrent</code>并发包下同步器类如何使用这个框架的概括:</p><p><code>ReentrantLock</code>可重入锁类使用同步状态保存(递归)锁的数量. 当一个锁被获取, 它也会<br>记录当前线程的标识符来检查递归并检查非法状态异常, 当错误线程想要释放锁时.<br>这个类也使用提供的<code>ConditionObject</code>类, 并导出其他的监控和检测方法.<br>这个类支持一个可选的<code>公平</code>模式通过内部声明两个不同的<code>AbstractQueuedSynchronizer</code>子类<br>(公平锁禁止插队)并且在构造时设置每一个<code>ReentrantLock</code>实例使用合适的子类.</p><p><code>ReentrantReadWriteLock</code>可重入读写锁类使用同步状态的16比特(右边)来保存写锁数量,<br>使用剩下的16比特(左边)保存读锁数量. 写锁的结构在其他方面和可重入锁一样. 读锁使用<br><code>acquireShared</code>方法来允许多个读者.</p><p><code>Semaphore</code>信号量类使用同步状态来代表数量. 当它到达0时, 所有获取<code>acquire</code>都可以通过.</p><p><code>FutureTask</code>类使用同步状态代表<code>future</code>对象的运行状态(初始化, 运行, 取消, 完成).<br>调用<code>release</code>来设置或取消一个<code>future</code>, 通过<code>acquire</code>来解锁等待计算结果的线程.</p><p><code>SynchronousQueue</code>同步队列类(一个CSP风格的变体)使用颞部的等待节点牌来匹配生产者<br>和消费者. 当消费者拿走物品时, 它使用同步状态允许生产者执行, 反之亦然.</p><p><code>java.util.concurrent</code>并发包的使用者当然可以为自定义的应用开发他们自己的同步器.<br>例如, 被考虑过但没有被引入到这个包里的WIN32事件, 二进制门栓, 集中管理的锁, 基于树的帷幕.</p><p>以上是关于AQS框架的原理和使用, 论文最后还有关于性能指数的测量请参考原文.</p><p><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">原文</a></p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><em>姬野永远提供翻译建议.</em></p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> concurrence </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AbstractQueuedSynchronizer</title>
      <link href="/2022/03/29/Code/Concurrence/AbstractQueuedSynchronizer/"/>
      <url>/2022/03/29/Code/Concurrence/AbstractQueuedSynchronizer/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="段1"><a href="#段1" class="headerlink" title="段1"></a>段1</h4><ul><li>Provides a framework for implementing blocking locks and related</li><li>synchronizers (semaphores, events, etc) that rely on</li><li>first-in-first-out (FIFO) wait queues.  This class is designed to</li><li>be a useful basis for most kinds of synchronizers that rely on a</li><li>single atomic <tt>int</tt> value to represent state. Subclasses</li><li>must define the protected methods that change this state, and which</li><li>define what that state means in terms of this object being acquired</li><li>or released. Given these, the other methods in this class carry</li><li>out all queuing and blocking mechanics. Subclasses can maintain</li><li>other state fields, but only the atomically updated <tt>int</tt></li><li>value manipulated using methods {@link #getState}, {@link</li><li>#setState} and {@link #compareAndSetState} is tracked with respect</li><li>to synchronization.</li></ul><blockquote><p>提供一个基于先进先出的等待队列的框架实现阻塞锁和相关的同步器(例如信号量, 事件等).<br>这个类仅仅依靠一个int的原子类来管理状态的设计作为大部分的同步器的基础.<br>子类必须定义执行方法来改变这个状态, 并且定义当这个对象被<code>acquired</code>和<code>released</code>的时候对应的状态含义.<br>考虑到这些, 该类中其他方法执行所有的排队阻塞机制.<br>子类可以维护其他的状态字段, 但是只有使用方法<code>getState</code>,<code>setState</code>和<code>compareAndSetState</code>进行原子更新的<code>int</code>值是用来追踪同步的.</p></blockquote><h4 id="段2"><a href="#段2" class="headerlink" title="段2"></a>段2</h4><ul><li><p>Subclasses should be defined as non-public internal helper</li><li>classes that are used to implement the synchronization properties</li><li>of their enclosing class.  Class</li><li><tt>AbstractQueuedSynchronizer</tt> does not implement any</li><li>synchronization interface.  Instead it defines methods such as</li><li>{@link #acquireInterruptibly} that can be invoked as</li><li>appropriate by concrete locks and related synchronizers to</li><li>implement their public methods.</li></ul><blockquote><p>子类应该被定义为非<code>public</code>的内部辅助类用来实现它们封装类的同步属性.<br><code>AbstractQueuedSynchronizer</code>类不实现任何同步接口.<br>它定义了<code>acquireInterruptibly</code>这样的方法被具体的锁视情况调用和相关的同步器来实现它们的公共方法.</p></blockquote><ul><li><p>This class supports either or both a default <em>exclusive</em></li><li>mode and a <em>shared</em> mode. When acquired in exclusive mode,</li><li>attempted acquires by other threads cannot succeed. Shared mode</li><li>acquires by multiple threads may (but need not) succeed. This class</li><li>does not &quot;understand&quot; these differences except in the</li><li>mechanical sense that when a shared mode acquire succeeds, the next</li><li>waiting thread (if one exists) must also determine whether it can</li><li>acquire as well. Threads waiting in the different modes share the</li><li>same FIFO queue. Usually, implementation subclasses support only</li><li>one of these modes, but both can come into play for example in a</li><li>{@link ReadWriteLock}. Subclasses that support only exclusive or</li><li>only shared modes need not define the methods supporting the unused mode.</li></ul><blockquote><p>这个类支持一个默认的互斥模式和一个共享模式.<br>当在互斥模式时被<code>acquire</code>, 其他<code>acquire</code>的线程不能成功.<br>共享模式下多线程同时<code>acquire</code>可能会(不是必须)成功.<br>这个类并不<code>理解</code>这些区别除了在这个机制当一个共享模式<code>acquire</code>成功, 另一个等待线程(如果存在)必须决定是否它也可以<code>acquire</code>.<br>在不同模式下等待的线程共享同一个<code>FIFO</code>队列.<br>通常, 子类只实现支持这些模式中的一个, 但是可以通过<code>ReadWriteLock</code>来全部演示.<br>只支持互斥模式或者共享模式的子类不需要定义方法来支持没用到的模式.</p></blockquote><h1 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h1><ul><li><p>This class defines a nested {@link ConditionObject} class that</li><li>can be used as a {@link Condition} implementation by subclasses</li><li>supporting exclusive mode for which method {@link</li><li>#isHeldExclusively} reports whether synchronization is exclusively</li><li>held with respect to the current thread, method {@link #release}</li><li>invoked with the current {@link #getState} value fully releases</li><li>this object, and {@link #acquire}, given this saved state value,</li><li>eventually restores this object to its previous acquired state.  No</li><li><tt>AbstractQueuedSynchronizer</tt> method otherwise creates such a</li><li>condition, so if this constraint cannot be met, do not use it.  The</li><li>behavior of {@link ConditionObject} depends of course on the</li><li>semantics of its synchronizer implementation.</li></ul><blockquote><p>这个类定义了一个嵌套类<code>ConditionObject</code>, 可以被子类用作支持互斥模式的<code>Condition</code>实现.<br>通过方法<code>isHeldExclusively</code>知道是否同步正在被当前线程互斥持有,被当前<code>getState</code>值调用的方法<code>release</code>完全的释放这个对象.<br>并且<code>acquire</code> 给予这个保存的<code>acquired</code>状态.<br>最终这个对象重新回到它先前的<code>acquired</code>状态.<br>没有一个<code>AbstractQueuedSynchronizer</code>方法创建一个<code>condition</code> 所以如果这个约束不能达成, 那么不用使用它.<br><code>ConditionObject</code>的行为依赖于同步器的实现机制.</p></blockquote><ul><li><p>This class provides inspection, instrumentation, and monitoring</li><li>methods for the internal queue, as well as similar methods for</li><li>condition objects. These can be exported as desired into classes</li><li>using an <tt>AbstractQueuedSynchronizer</tt> for their</li><li>synchronization mechanics.</li></ul><blockquote><p>这个类为内部队列和<code>conditon</code>对象提供观测, 构件, 监控器方法.<br>这些可以被导出到使用<code>AbstractQueuedSynchronizer</code>作为它们同步机制的类里.</p></blockquote><ul><li><p>Serialization of this class stores only the underlying atomic</li><li>integer maintaining state, so deserialized objects have empty</li><li>thread queues. Typical subclasses requiring serializability will</li><li>define a <tt>readObject</tt> method that restores this to a known</li><li>initial state upon deserialization.</li></ul><blockquote><p>该类的序列化仅仅保存底层的原子<code>integer</code>维护状态, 所以解序列化对象只有空的线程队列.<br>经典的子类需要序列化将定义一个<code>readObject</code>方法, 解序列化时用来重新加载自身数据到一个到初始化状态.</p></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li><p>To use this class as the basis of a synchronizer, redefine the</li><li>following methods, as applicable, by inspecting and&#x2F;or modifying</li><li>the synchronization state using {@link #getState}, {@link</li><li>#setState} and&#x2F;or {@link #compareAndSetState}:</li></ul><blockquote><p>为了使用这个类作为一个同步器的基础, 重新定义以下方法, 以作可用的, 通过观测或修改同步状态<br><code>getState</code><br><code>setState</code><br><code>compareAndSetState</code></p></blockquote> <ul> <li> tryAcquire <li> tryRelease <li> tryAcquireShared <li> tryReleaseShared <li> isHeldExclusively </ul> <ul><li>Each of these methods by default throws {@link</li><li>UnsupportedOperationException}.  Implementations of these methods</li><li>must be internally thread-safe, and should in general be short and</li><li>not block. Defining these methods is the <em>only</em> supported</li><li>means of using this class. All other methods are declared</li><li><tt>final</tt> because they cannot be independently varied.</li></ul><blockquote><p>以上这些方法中每个方法都默认会抛出异常<code>UnsupportedOperationException</code>.<br>这些方法的实现必须是线程安全的, 并且应该大体是简短, 非阻塞的.<br>定义这些方法是使用该类的唯一支持的方法.<br>所有其他的方法被定义为<code>final</code>因为它们不能被单独改变.</p></blockquote><ul><li><p>You may also find the inherited methods from {@link</li><li>AbstractOwnableSynchronizer} useful to keep track of the thread</li><li>owning an exclusive synchronizer.  You are encouraged to use them</li><li>– this enables monitoring and diagnostic tools to assist users in</li><li>determining which threads hold locks.</li><li></li><li><p>Even though this class is based on an internal FIFO queue, it</li><li>does not automatically enforce FIFO acquisition policies.  The core</li><li>of exclusive synchronization takes the form:</li></ul><blockquote><p>你可能一发现了从<code>AbstractOwnableSynchronizer</code>继承的方法有利于追踪拥有一个互斥同步器的线程.<br>你被鼓励使用它们.<br>这个使得监控器和诊断工具帮助用户决定哪一个线程获取锁.</p><p>即使该类是基于一个内部<code>FIFO</code>队列, 它并不会自动的强迫<code>FIFO</code>获取策略.<br>互斥同步器的核心使用以下形式:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Acquire:</span><br><span class="line">    while (!tryAcquire(arg)) &#123;</span><br><span class="line">         enqueue thread if it is not already queued;</span><br><span class="line">         possibly block current thread;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">Release:</span><br><span class="line">    if (tryRelease(arg))</span><br><span class="line">       unblock the first queued thread;</span><br></pre></td></tr></table></figure><ul><li>(Shared mode is similar but may involve cascading signals.)</li></ul><blockquote><p>共享模式类似, 但是可能包括大量的信号</p></blockquote><ul><li><p><a name="barging">Because checks in acquire are invoked before</li><li>enqueuing, a newly acquiring thread may <em>barge</em> ahead of</li><li>others that are blocked and queued.  However, you can, if desired,</li><li>define <tt>tryAcquire</tt> and&#x2F;or <tt>tryAcquireShared</tt> to</li><li>disable barging by internally invoking one or more of the inspection</li><li>methods, thereby providing a <em>fair</em> FIFO acquisition order.</li><li>In particular, most fair synchronizers can define <tt>tryAcquire</tt></li><li>to return <tt>false</tt> if {@link #hasQueuedPredecessors} (a method</li><li>specifically designed to be used by fair synchronizers) returns</li><li><tt>true</tt>.  Other variations are possible.</li></ul><blockquote><p>因为在<code>入队</code>之前<code>acquire</code>包含了检测, 一个新的正在<code>acquire</code>的线程可能会<code>插队</code>到其他正在排队或阻塞的线程前面.<br>然而, 你可以, 如果愿意的话定义<code>tryAcquire</code>并且&#x2F;或者<code>tryAcquireShared</code>来禁止<code>插队</code>, 通过内部调用一个或则多个监测方法,由此提供一个公平的<code>FIFO</code>获取顺序.<br>实践中, 大部分公平的同步器可以定义<code>tryAcquire 来返回</code>false<code>, 如果</code>hasQueuedPredecessors<code>(为公平同步器专门设计的一个方法)返回</code>true&#96;.<br>也可以是其他的变化.</p></blockquote><ul><li><p>Throughput and scalability are generally highest for the</li><li>default barging (also known as <em>greedy</em>,</li><li><em>renouncement</em>, and <em>convoy-avoidance</em>) strategy.</li><li>While this is not guaranteed to be fair or starvation-free, earlier</li><li>queued threads are allowed to recontend before later queued</li><li>threads, and each recontention has an unbiased chance to succeed</li><li>against incoming threads.  Also, while acquires do not</li><li>&quot;spin&quot; in the usual sense, they may perform multiple</li><li>invocations of <tt>tryAcquire</tt> interspersed with other</li><li>computations before blocking.  This gives most of the benefits of</li><li>spins when exclusive synchronization is only briefly held, without</li><li>most of the liabilities when it isn’t. If so desired, you can</li><li>augment this by preceding calls to acquire methods with</li><li>“fast-path” checks, possibly prechecking {@link #hasContended}</li><li>and&#x2F;or {@link #hasQueuedThreads} to only do so if the synchronizer</li><li>is likely not to be contended.</li></ul><blockquote><p>吞吐量和可观测行对于默认的冲突(也被称为贪婪的放弃和车队避让)策略来说是最重要的.<br>但是这不能保证公平或免于饥饿, 先入队的线程允许和后入队的线程竞争, 并且每次竞争有一个无差别的机会获得成功.<br>并且, 当<code>acquire</code>没有在通常意义上的自旋, 在阻塞之前它们可能会多次调用<code>tryAcquire</code>并掺杂着其他的计算.<br>当互斥同步纸只是唯一持有时, 这个给自旋带来了极大的优势, 不是这个情况就会失去很多优势.<br>如果需要的话, 你可以增加这个通过先前的调用来请求方法<code>最快路径</code>检查, 使用预检查的方法<code>hasContended</code>和&#x2F;或<code>hasQueuedThreads</code>可以使得同步器减少竞争的情况.</p></blockquote><ul><li><p>This class provides an efficient and scalable basis for</li><li>synchronization in part by specializing its range of use to</li><li>synchronizers that can rely on <tt>int</tt> state, acquire, and</li><li>release parameters, and an internal FIFO wait queue. When this does</li><li>not suffice, you can build synchronizers from a lower level using</li><li>{@link java.util.concurrent.atomic atomic} classes, your own custom</li><li>{@link java.util.Queue} classes, and {@link LockSupport} blocking</li><li>support.</li></ul><blockquote><p>这个类为同步器提供一个高效的, 可观测的基准的方式一部分是依靠以下参数<br>1.<code>int</code> state<br>2.<code>acquire</code><br>3.<code>release</code><br>4.一个<code>FIFO</code>等待队列<br>如果这些还不满足需要, 你可以在一个低级别上自己构建同步器, 使用如下元素<br>1.<code>java.util.concurrent.atomic</code>包下原子类<br>2.<code>java.util.Queue</code>队列类<br>3.<code>LockSupport</code>阻塞支持</p></blockquote><h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><ul><li><h3>Usage Examples</h3></li><li><p>Here is a non-reentrant mutual exclusion lock class that uses</li><li>the value zero to represent the unlocked state, and one to</li><li>represent the locked state. While a non-reentrant lock</li><li>does not strictly require recording of the current owner</li><li>thread, this class does so anyway to make usage easier to monitor.</li><li>It also supports conditions and exposes</li><li>one of the instrumentation methods:</li></ul><blockquote><p>下面是一个不可重入的互斥锁类, 使用<code>0</code>代表未锁定状态, <code>1</code>表示锁定状态.<br>因为一个非可重入的锁没有严格要求记录当前拥有线程, 这样实现可以让<code>monitor</code>用起来更简单.<br>它也支持<code>condition</code>和暴露其中的构件方法:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 我们的内部帮助类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="comment">// 报告是否在锁的状态</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取锁如果state是0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">      <span class="type">assert</span> <span class="variable">acquires</span> <span class="operator">=</span>= <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 释放锁: 设置state为0</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">      <span class="type">assert</span> <span class="variable">releases</span> <span class="operator">=</span>= <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">      <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">      setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">      setState(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 提供condition</span></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>(); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 解序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">      s.defaultReadObject();</span><br><span class="line">      setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//  sync对象实现最复杂的工作</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>                &#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>          &#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>              &#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span>   &#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span>         &#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span> &#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">      <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Here is a latch class that is like a {@link CountDownLatch}</li><li>except that it only requires a single <tt>signal</tt> to</li><li>fire. Because a latch is non-exclusive, it uses the <tt>shared</tt></li><li>acquire and release methods.</li></ul><blockquote><p>下面是一个类似<code>CountDownLatch</code>的门栓类<br>它只<code>acquire</code>一个单一的<code>signal</code>来唤醒.<br>因为一个门栓是非互斥的, 它使用<code>shared</code>来<code>acquire</code>和<code>release</code>方法.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BooleanLatch</span> &#123;</span><br><span class="line">    <span class="comment">// 内部帮助类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">      <span class="comment">// 是否唤醒 state: 非0唤醒, 0未唤醒</span></span><br><span class="line">      <span class="type">boolean</span> <span class="title function_">isSignalled</span><span class="params">()</span> &#123; <span class="keyword">return</span> getState() != <span class="number">0</span>; &#125;</span><br><span class="line">      <span class="comment">// 唤醒 1, 未唤醒 -1, 返回值&lt;0, 表示可以获取</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> ignore)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isSignalled() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将state设为1 来释放</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> ignore)</span> &#123;</span><br><span class="line">        setState(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSignalled</span><span class="params">()</span> &#123; <span class="keyword">return</span> sync.isSignalled(); &#125;</span><br><span class="line">    <span class="comment">// 唤醒其他线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>         &#123; sync.releaseShared(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">// 当前线程等待</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123; sync.acquireSharedInterruptibly(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>When meaningful, each synchronizer supports:</p><ul><li>Nonblocking synchronization attempts (for example,<br>tryLock) as well as blocking versions.</li><li>Optional timeouts, so applications can give up waiting.</li><li>Cancellability via interruption, usually separated into one<br>version of acquire that is cancellable, and one that isn’t</li></ul><p>同步器应该支持:</p><ul><li>非阻塞的同步尝试(比如, <code>tryLock</code>) 和阻塞版本.</li><li>可选的超时, 这样应用可以放弃等待.</li><li>通过中断来取消, 通常是分开在两个版本的<code>acquire</code>,一个是可取消, 一个不能.</li></ul><p>JVM优化锁的策略是0竞争.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// park</span></span><br><span class="line">    LockSupport.park(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="comment">// todo 循环里的park 后面一定跟着中断检查</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://sunchunya314.github.io/">https://sunchunya314.github.io/</a></p><p>22</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Code</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Various flavors of acquire, varying in exclusive/shared and</span></span><br><span class="line"><span class="comment">     * control modes.  Each is mostly the same, but annoyingly</span></span><br><span class="line"><span class="comment">     * different.  Only a little bit of factoring is possible due to</span></span><br><span class="line"><span class="comment">     * interactions of exception mechanics (including ensuring that we</span></span><br><span class="line"><span class="comment">     * cancel if tryAcquire throws exception) and other control, at</span></span><br><span class="line"><span class="comment">     * least not without hurting performance too much.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">     * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量: 标记是否获取失败</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 局部变量: 标记是否被中断</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 自旋</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 前节点</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// 2步检查, 1.前节点是否头结点 2.1为真则尝试获取锁</span></span><br><span class="line">                <span class="comment">// 1步操作, 1.更新头结点,跳出循环, 返回中断状态</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 检查1: 前节点==头结点</span></span><br><span class="line"><span class="comment">                 *     检查2: 尝试获取锁</span></span><br><span class="line"><span class="comment">                 *         操作1: 更新头结点并返回false</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="comment">// 失败标记设为false</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 返回中断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果前节点不是头结点, 或者获取锁失败 -&gt; 进行两步检查,两步步操作</span></span><br><span class="line">                <span class="comment">// 检查1.检查根据前节点等待状态决定当前线程是否需要阻塞 2.检查阻塞是否被中断</span></span><br><span class="line">                <span class="comment">// 操作1. 根据检查1的结果进行阻塞; 操作2. 根据检查2的结果设置局部变量中断标记为true  </span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 缩进表示执行条件上一步为真</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 检查1: 需要阻塞</span></span><br><span class="line"><span class="comment">                 *    操作1: 阻塞</span></span><br><span class="line"><span class="comment">                 *    检查2: 被中断</span></span><br><span class="line"><span class="comment">                 *      操作2: 标记中断   </span></span><br><span class="line"><span class="comment">                 */</span> </span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Code</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回前节点, 目的是为了用前节点的状态做判断, 前节点等待状态是取消或者发生改变, 则唤醒当前节点. </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">                    t = tail;</span><br><span class="line">                    node.pre  = t;</span><br><span class="line">                    compareAndSetTail(t,node);</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers a node from a condition queue onto sync queue.</span></span><br><span class="line"><span class="comment">     * Returns true if successful.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successfully transferred (else the node was</span></span><br><span class="line"><span class="comment">     * cancelled before signal).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">         * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">         * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">         * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">         * 猜测发生改变的原因最大的可能是前节点发生了改变,变成了头结点. 但是错误唤醒当前的节点并没有太大的危害</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Code</span> &#123; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * java.util.concurrent.locks.AbstractQueuedSynchronizer#apparentlyFirstQueuedIsExclusive</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if the apparent first queued thread, if one</span></span><br><span class="line"><span class="comment">     * exists, is waiting in exclusive mode.  If this method returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125;, and the current thread is attempting to acquire in</span></span><br><span class="line"><span class="comment">     * shared mode (that is, this method is invoked from &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125;) then it is guaranteed that the current thread</span></span><br><span class="line"><span class="comment">     * is not the first queued thread.  Used only as a heuristic in</span></span><br><span class="line"><span class="comment">     * ReentrantReadWriteLock.</span></span><br><span class="line"><span class="comment">     * 检查是否需要互斥 如果队列里第一个节点不是共享模式, 且存在线程则需要互斥.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> &#123;</span><br><span class="line">        Node h, s;</span><br><span class="line">        <span class="keyword">return</span> (h = head) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (s = h.next)  != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            !s.isShared()         &amp;&amp;</span><br><span class="line">            s.thread != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// java.util.concurrent.locks.ReentrantReadWriteLock.NonfairSync#readerShouldBlock</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">         * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">         * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">         * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">         * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">         * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">         * 防止写线程饥饿, 当等待队列里第一个节点是写线程那么当前读线程阻塞.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Latch</code>的作用是阻塞某(几)个线程的执行,等到满足数量的其他线程执行结束后唤醒.</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> concurrence </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务解决方案之TCC</title>
      <link href="/2022/03/29/Cloud/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BTCC/"/>
      <url>/2022/03/29/Cloud/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BTCC/</url>
      
        <content type="html"><![CDATA[<h3 id="1-TCC分布式事务模型"><a href="#1-TCC分布式事务模型" class="headerlink" title="1. TCC分布式事务模型"></a>1. TCC分布式事务模型</h3><h4 id="1-1需要业务系统提供三段业务逻辑："><a href="#1-1需要业务系统提供三段业务逻辑：" class="headerlink" title="1.1需要业务系统提供三段业务逻辑："></a>1.1需要业务系统提供三段业务逻辑：</h4><ol><li><p>一阶段: 初步操作 Try：完成所有业务检查，预留必须的业务资源。</p></li><li><p>二阶段: 确认操作 Confirm：真正执行的业务逻辑，不做任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务能且只能成功一次。</p></li><li><p>二阶段: 取消操作 Cancel：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。</p></li></ol><p>其中一个事务中<code>确认</code>和<code>取消</code>只有一个会执行. 所以 TCC 模型是两阶段操作模型.</p><h4 id="1-2-需要实现的功能"><a href="#1-2-需要实现的功能" class="headerlink" title="1.2 需要实现的功能"></a>1.2 需要实现的功能</h4><ul><li>支持空回滚: 没有执行一阶段Try, 调用二阶段回滚方法返回成功</li><li>幂等: 所有方法执行一次和多次结果一样</li><li>防悬挂: 对于同一个全局事务, 执行了二阶段操作, 不能再执行一阶段操作</li><li>并发控制: 一个全局事务完成了一阶段之后, 不需要完成二阶段操作, 其他事务即可操作该记录</li></ul><h3 id="2-账务系统TCC模型设计"><a href="#2-账务系统TCC模型设计" class="headerlink" title="2. 账务系统TCC模型设计"></a>2. 账务系统TCC模型设计</h3><p>以金融核心链路里的账务服务来分析一下。首先一个最简化的账务模型就是图中所列，每个用户或商户有一个账户及其可用余额。然后，分析下账务服务的所有业务逻辑操作，无论是交易、充值、转账、退款等，都可以认为是对账户的加钱与扣钱。</p><p><img src="http://101.132.193.91:4999/Public/Uploads/2020-08-17/5f3a470f0ab1f.png"></p><p>可以把账务系统拆分成两套 TCC 接口，即两个 TCC Resource:</p><ul><li>一个是加钱 TCC 接口;</li><li>一个是扣钱 TCC 接口。</li></ul><h4 id="2-1扣钱流程"><a href="#2-1扣钱流程" class="headerlink" title="2.1扣钱流程"></a>2.1扣钱流程</h4><p> <img src="http://101.132.193.91:4999/Public/Uploads/2020-08-17/5f3a47ac6b477.png"></p><ul><li>检查悬挂, Try 操作账户扣钱, 插入一条流水记录, 状态为<code>PROCESSING</code></li><li>Confirm 不操作账户, 更新记录状态为 <code>CONFIRM</code></li><li>Cancel 读取流水记录, 操作账户加钱, 更新记录状态为 <code>CANCEL</code></li></ul><h4 id="2-2-加钱流程"><a href="#2-2-加钱流程" class="headerlink" title="2.2 加钱流程"></a>2.2 加钱流程</h4><ul><li>检查悬挂, Try 不操作账户, 插入一条流水记录, 状态为<code>PROCESSING</code></li><li>Confirm 读取流水记录, 给账户加钱, 更新记录状态为 <code>CONFIRM</code></li><li>Cancel 不操作账户, 更新记录状态为 <code>CANCEL</code></li></ul><h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h3><h4 id="3-1-数据库实现"><a href="#3-1-数据库实现" class="headerlink" title="3.1 数据库实现"></a>3.1 数据库实现</h4><ul><li>账户表</li><li>转账事务表<br><img src="/2022/03/29/Cloud/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BTCC/account_table.jpg"></li></ul><h4 id="3-2-操作流程"><a href="#3-2-操作流程" class="headerlink" title="3.2 操作流程"></a>3.2 操作流程</h4><p>扣钱操作: 扣减n 元</p><table><thead><tr><th>操作</th><th>转账事务表</th><th>账户表</th></tr></thead><tbody><tr><td>Try</td><td>检查悬挂, 插入一条记录, 状态为<code>进行中</code></td><td><code>money</code>减去n</td></tr><tr><td>Confirm</td><td>根据<code>gtx_id</code>查询记录, 并标记为<code>已确认</code></td><td>不操作</td></tr><tr><td>Cancel</td><td>根据<code>gtx_id</code>查询记录, 获取<code>amount</code>, 标记为<code>已取消</code></td><td><code>money</code>增加n</td></tr></tbody></table><p>加钱操作: 增加n 元</p><table><thead><tr><th>操作</th><th>转账事务表</th><th>账户表</th></tr></thead><tbody><tr><td>Try</td><td>检查悬挂, 插入一条记录, 状态为<code>进行中</code></td><td>不操作</td></tr><tr><td>Confirm</td><td>根据<code>gtx_id</code>查询记录,获取<code>amount</code>, 并标记为<code>已确认</code></td><td><code>money</code>增加n</td></tr><tr><td>Cancel</td><td>根据<code>gtx_id</code>查询记录,  标记为<code>已取消</code></td><td>不操作</td></tr></tbody></table><ul><li><code>检查悬挂</code>: 根据<code>gtx_id</code>查询记录, 如果存在则不操作, 直接返回.</li></ul><h4 id="3-3-功能实现"><a href="#3-3-功能实现" class="headerlink" title="3.3 功能实现"></a>3.3 功能实现</h4><h5 id="3-3-1-空回滚"><a href="#3-3-1-空回滚" class="headerlink" title="3.3.1 空回滚"></a>3.3.1 空回滚</h5><p>在<code>Cancel</code>操作中, 对转账事务表, 根据<code>gtx_id</code>查询记录, 如果没有则直接返回.</p><h5 id="3-3-2-幂等"><a href="#3-3-2-幂等" class="headerlink" title="3.3.2 幂等"></a>3.3.2 幂等</h5><ul><li>Try: 通过<code>检查悬挂</code>实现</li><li>Confirm: 通过根据<code>gtx_id</code>查询转账事务表记录,如果状态不是<code>进行中</code>,则不操作, 返回.</li><li>Cancel: 同上.</li></ul><h5 id="3-3-3-防悬挂"><a href="#3-3-3-防悬挂" class="headerlink" title="3.3.3 防悬挂"></a>3.3.3 防悬挂</h5><p>在Try阶段通过<code>检查悬挂</code>实现.</p><h5 id="3-3-4-并发控制"><a href="#3-3-4-并发控制" class="headerlink" title="3.3.4 并发控制"></a>3.3.4 并发控制</h5><p>通过<code>转账事务表</code>的事务记录实现并发隔离, <code>Try</code>, <code>Confirm</code>, <code>Cancel</code>每个操作各自都是原子的.</p><p>扣钱操作: 事务1 扣减m 元, 事务2 扣减 n元</p><table><thead><tr><th>操作</th><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>Try</td><td>当前<code>money</code>减去m</td><td><code>money</code>在<code>money</code>减去m的基础上减去n</td></tr><tr><td>Confirm</td><td>不操作</td><td>不操作</td></tr><tr><td>Cancel</td><td>当前<code>money</code>增加m</td><td>当前<code>money</code>增加n</td></tr></tbody></table><p>加钱操作:事务1 增加m 元, 事务2 增加n元</p><table><thead><tr><th>操作</th><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>Try</td><td>不操作</td><td>不操作</td></tr><tr><td>Confirm</td><td>当前<code>money</code>增加m</td><td><code>money</code>在<code>money</code>增加m的基础上增加n</td></tr><tr><td>Cancel</td><td>不操作</td><td>不操作</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Demo</title>
      <link href="/2022/03/28/Demo/"/>
      <url>/2022/03/28/Demo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 个人博客（第一层级） </category>
          
          <category> Hexo博客（第二层级） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
